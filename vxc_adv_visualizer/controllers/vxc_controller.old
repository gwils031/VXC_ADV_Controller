"""Velmex VXC XY Stage Controller with ASCII command protocol.

Simple implementation matching reference code exactly.
"""

import serial
import time
import logging
from typing import Optional, Tuple

logger = logging.getLogger(__name__)


class VXCController:
    """Controller for Velmex VXC XY stage via USB/Serial.
    
    Simple ASCII command protocol matching Velmex documentation.
    """
    
    def __init__(self, port: str = 'COM8', baudrate: int = 57600, timeout: float = 1):
        """Initialize VXC controller connection.
        
        Args:
            port: COM port name (default: 'COM8')
            baudrate: Baud rate (default: 57600)
            timeout: Serial timeout in seconds (default: 1)
        """
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.ser = None
        self.online = False
        
    def connect(self) -> bool:
        """Establish serial connection to VXC controller.
        
        Returns:
            True if connection successful
        """
        try:
            self.ser = serial.Serial(
                port=self.port,
                baudrate=self.baudrate,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                timeout=self.timeout
            )
            time.sleep(0.1)  # Allow connection to stabilize
            logger.info(f"Connected to {self.port} at {self.baudrate} baud")
            return True
        except serial.SerialException as e:
            logger.error(f"Connection failed: {e}")
            return False
    
    def disconnect(self) -> None:
        """Close serial connection."""
        if self.ser and self.ser.is_open:
            self.go_offline()
            self.ser.close()
            logger.info("Disconnected")
    
    def close(self) -> None:
        """Alias for disconnect() for compatibility."""
        self.disconnect()
    
    def send_command(self, command: str, wait_for_response: bool = False, response_type: str = 'ready') -> Optional[str]:
        """Send command to VXC controller.
        
        Args:
            command: Command string to send
            wait_for_response: Whether to wait for a response
            response_type: Type of response expected ('ready', 'value', 'status')
            
        Returns:
            Response string if wait_for_response=True, otherwise None
        """
        if not self.ser or not self.ser.is_open:
            logger.error("Not connected")
            return None
        
        try:
            # Clear any pending data
            self.ser.reset_input_buffer()
            
            # Send command
            self.ser.write(command.encode('ascii'))
            self.ser.flush()
            logger.debug(f"→ {command}")
            
            if wait_for_response:
                response = ""
                start_time = time.time()
                
                while True:
                    if self.ser.in_waiting > 0:
                        char = self.ser.read(1).decode('ascii', errors='ignore')
                        response += char
                        
                        # Check for completion characters
                        if response_type == 'ready' and '^' in response:
                            break
                        elif response_type == 'value' and '\r' in response:
                            break
                        elif response_type == 'status' and char in ['B', 'R', 'J', 'b', 'F']:
                            break
                    
                    # Timeout check
                    if time.time() - start_time > self.timeout:
                        logger.warning(f"Timeout waiting for response")
                        break
                
                logger.debug(f"← {response.strip()}")
                return response.strip()
            
            return None
            
        except Exception as e:
            logger.error(f"Command error: {e}")
            return None
    
    def go_online(self, echo: bool = False) -> None:
        """Put VXC in Online mode.
        
        Args:
            echo: If True, use 'E' (echo on), if False use 'F' (echo off)
        """
        command = 'E' if echo else 'F'
        self.send_command(command)
        self.online = True
        logger.info(f"Online mode {'(echo on)' if echo else '(echo off)'}")
        time.sleep(0.1)
    
    def go_offline(self) -> None:
        """Put VXC in Offline/Jog mode."""
        if self.online:
            self.send_command('Q')
            self.online = False
            logger.info("Offline mode (Jog)")
    
    def clear_program(self) -> None:
        """Clear all commands from current program."""
        self.send_command('C')
        logger.debug("Program cleared")
    
    def verify_status(self) -> Optional[str]:
        """Verify controller status.
        
        Returns:
            'R' = Ready, 'B' = Busy, 'J' = Jog mode, 'b' = Jogging, 'F' = Fault
        """
        response = self.send_command('V', wait_for_response=True, response_type='status')
        
        status_map = {
            'R': 'Ready',
            'B': 'Busy',
            'J': 'Jog mode',
            'b': 'Jogging',
            'F': 'Fault'
        }
        
        if response and response in status_map:
            logger.info(f"Status: {status_map[response]}")
            return response
        else:
            logger.warning(f"Unknown status: {response}")
            return None
    
    def get_position(self, motor: int = 1) -> Optional[int]:
        """Get current motor position.
        
        Args:
            motor: Motor number (1-4)
            
        Returns:
            Position as integer, or None if error
        """
        position_commands = {1: 'X', 2: 'Y', 3: 'Z', 4: 'T'}
        
        if motor not in position_commands:
            logger.error(f"Invalid motor number: {motor}")
            return None
        
        response = self.send_command(position_commands[motor], 
                                     wait_for_response=True, 
                                     response_type='value')
        
        if response:
            try:
                position = int(response.strip())
                logger.debug(f"Motor {motor} position: {position}")
                return position
            except ValueError:
                logger.error(f"Invalid position response: {response}")
                return None
        return None
    
    def zero_position(self) -> None:
        """Zero all motor positions."""
        self.send_command('N')
        logger.info("Position zeroed")
    
    def step_motor(self, motor: int = 1, steps: int = 400, speed: int = 2000, 
                   acceleration: int = 2, wait: bool = True) -> bool:
        """Step motor a specified number of steps.
        
        Args:
            motor: Motor number (1-4)
            steps: Number of steps (positive or negative)
            speed: Speed in steps/second (1-6000)
            acceleration: Acceleration value (0-127)
            wait: Wait for movement to complete
            
        Returns:
            True if successful, False otherwise
        """
        if not self.online:
            logger.error("Must be online to send motion commands")
            return False
        
        # Clear previous commands
        self.clear_program()
        
        # Set acceleration
        accel_cmd = f'A{motor}M{acceleration},'
        self.send_command(accel_cmd)
        
        # Set speed
        speed_cmd = f'S{motor}M{speed},'
        self.send_command(speed_cmd)
        
        # Set index (step) command
        index_cmd = f'I{motor}M{steps},'
        self.send_command(index_cmd)
        
        logger.info(f"Commands sent: Motor {motor}, {steps} steps at {speed} steps/sec")
        
        # Run the program
        response = self.send_command('R', wait_for_response=wait, response_type='ready')
        
        if wait and response and '^' in response:
            logger.info("Movement complete")
            return True
        elif wait:
            logger.warning("Movement may not have completed properly")
            return False
        
        return True
    
    def stop_motor(self) -> None:
        """Decelerate motor to stop."""
        self.send_command('D')
        logger.info("Stop command sent (decelerate)")
    
    def kill_motion(self) -> None:
        """Immediately stop all motion."""
        self.send_command('K')
        logger.info("Kill command sent (immediate stop)")
    
    # ========== Compatibility methods for GUI ==========
    
    def move_absolute(self, x: Optional[float] = None, y: Optional[float] = None) -> None:
        """Move to absolute position.
        
        Args:
            x: Target X position in steps
            y: Target Y position in steps
        """
        if x is not None:
            current_x = self.get_position(motor=1)
            if current_x is not None:
                dx = int(x - current_x)
                if dx != 0:
                    self.step_motor(motor=1, steps=dx)
        
        if y is not None:
            current_y = self.get_position(motor=2)
            if current_y is not None:
                dy = int(y - current_y)
                if dy != 0:
                    self.step_motor(motor=2, steps=dy)
        motor_map = {'X': 'C', 'Y': 'D'}
        motor = motor_map[axis]
        
        # Send index command: "C I +1000" or "D I -500"
        cmd = f"{motor} I {steps:+d}"
        self.send_command(cmd, wait_ms=100)
        
        logger.info(f"{axis} axis: moved {steps} steps")
    
    def move_absolute(self, x: Optional[float] = None, y: Optional[float] = None) -> None:
        """Move to absolute position.
        
        Args:
            x: Target X position in steps
            y: Target Y position in steps
        """
        current_x, current_y = self.get_position()
        
        if x is not None:
            dx = int(x - current_x)
            if dx != 0:
                self.step_motor('X', dx)
        
        if y is not None:
            dy = int(y - current_y)
            if dy != 0:
                self.step_motor('Y', dy)
    
    def zero_position(self) -> None:
        """Zero current position (set as origin)."""
        self.send_command("N", wait_ms=100)
        logger.info("Position zeroed")
    
    def stop_motor(self) -> None:
        """Stop all motor motion."""
        self.send_command("D", wait_ms=50)
        logger.info("Motors stopped")
    
    def set_speed(self, axis: str, speed: int) -> None:
        """Set motor speed.
        
        Args:
            axis: 'X' or 'Y'
            speed: Speed value (1-6000 steps/sec)
        """
        motor_map = {'X': 'C', 'Y': 'D'}
        motor = motor_map.get(axis)
        
        if motor:
            cmd = f"{motor} S{speed}"
            self.send_command(cmd, wait_ms=50)
            logger.debug(f"{axis} speed set to {speed}")
    
    def set_acceleration(self, axis: str, accel: int) -> None:
        """Set motor acceleration.
        
        Args:
            axis: 'X' or 'Y'
            accel: Acceleration value
        """
        motor_map = {'X': 'C', 'Y': 'D'}
        motor = motor_map.get(axis)
        
        if motor:
            cmd = f"{motor} A{accel}"
            self.send_command(cmd, wait_ms=50)
            logger.debug(f"{axis} acceleration set to {accel}")
